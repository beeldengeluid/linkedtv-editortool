/*
The chapter collection contains all of the curated data:
- annotations (consisting of: 'entities' & 'enrichments' & 'information cards')
- timing information per annotation
*/

angular.module('linkedtv').factory('chapterCollection',
	['$rootScope', 'conf', 'imageService', 'entityCollection', 'shotCollection', 'subtitleCollection',
	 'dataService', 'timeUtils', 'entityExpansionService', 'loggingService', 'idUtils', 'synchronizationService',
	 function($rootScope, conf, imageService, entityCollection, shotCollection,
	 	subtitleCollection, dataService, timeUtils, entityExpansionService, loggingService, idUtils,
	 	synchronizationService) {

	var TYPE_AUTO = 'auto';
	var TYPE_CURATED = 'curated';
	var _chapters = [];
	var _activeChapter = null;
	var _thumbBaseUrl = null;
	var _thumbUrl = null;
	var _srtUrl = null;
	var _observers = [];
	var _expandedEntities = {}

	//load the chapter collection (this will trigger the controllers that are listening to the chapterCollection)
	function initCollectionData(provider, resourceData, curatedData) {
		console.debug('Initializing chapter data');
		_thumbBaseUrl = resourceData.thumbBaseUrl;
		_thumbUrl = resourceData.thumbUrl;
		_srtUrl = resourceData.srtUrl;
		var chapters = [];
		//load curated data from ET storage
		if (curatedData) {
			console.debug('Loading curations stored in the ET storage...');
			chapters = curatedData.chapters;
			_.each(chapters, function(c) {
				c.type = TYPE_CURATED;
			});
		}
		//always add the autogenerated chapters
		addAutogeneratedChapterData(chapters, resourceData);

		//sort the chapters by start time
		chapters.sort(function(a, b) {
			return a.start - b.start;
		});
		setChapters(chapters);

		//FIXME call this as a proper callback
		onChapterInitialized();
	}

	function onChapterInitialized() {
		//synchronize the curated data with the configured synchronization platform
		if(conf.programmeConfig.synchronization && conf.programmeConfig.synchronization.syncOnLoad) {
			synchronizationService.synchronize(onSynchronizationComplete);
		}
	}

	function onSynchronizationComplete(success) {
		console.debug('Synchronization complete: ' + success)
		if(success) {
			//TODO make sure to set the solrId for all the chapters
			_.each(_chapters, function(c) {
				c.solrId = c.mediaFragmentId;
			});
			saveOnServer();
		}
	}

	//This function adds the automatically generated chapters to the overall list of chapters (that are in memory)
	function addAutogeneratedChapterData(chapters, resourceData) {
		var autoChapters = resourceData.chapters;
		_.each(autoChapters, function(c) {
			c.type = TYPE_AUTO;
			chapters.push(c);
		});
	}

	//important function that makes sure that chapters have dimensions assigned to them at all times
	//also makes sure the correct thumbnail is set and that the start and end times are available in human readable format
	function setBasicProperties(chapter, updateDimensionData) {
		//only update the guid if it is not there yet
		if(!chapter.guid) {
			chapter.guid = idUtils.guid();
		}

		//make sure the dimension data is properly copied to the object
		if(updateDimensionData) {
			var dimensions = {};
			_.each(conf.programmeConfig.dimensions, function(d) {
				//copy the properties from the saved dimension
				var temp = {};
				if(chapter.dimensions && chapter.dimensions[d.id]) {
					_.each(chapter.dimensions[d.id], function(value, key) {
						if(key != '$$hashKey') {//FIXME ugly!
							temp[key] = value;
						}
					});
				} else {//if the dimension does not exist in the storage add it from the config
					_.each(d, function(value, key) {
						if(key != '$$hashKey') {//FIXME ugly!
							temp[key] = value;
						}
					});
				}
				dimensions[d.id] = temp;
			});
			chapter.dimensions = dimensions;
		}

		//always make sure to set the poster and start times
		chapter.poster = imageService.getThumbnail(_thumbBaseUrl, _thumbUrl, chapter.start);
		chapter.prettyStart = timeUtils.toPrettyTime(chapter.start);
		chapter.prettyEnd = timeUtils.toPrettyTime(chapter.end);
		chapter.mediaFragmentId = idUtils.generateMediaFragmentId(chapter.start, chapter.end);
	}

	function addObserver(observer) {
		_observers.push(observer);
	}

	function removeObserver() {
		_observers.pop();
	}

	function notifyObservers() {
		for (o in _observers) {
			_observers[o](_chapters);
		}
	}

	function setChapters(chapters) {
		//make sure all the basic properties are added to each chapter
		_.each(chapters, function(c) {
			setBasicProperties(c, true);
		});
		_chapters = chapters;
		notifyObservers();
	}

	function getChapters() {
		return _chapters;
	}

	function getCuratedChapters() {
		return _.filter(_chapters, function(c) {
			return c.type == TYPE_CURATED;
		})
	}

	function setActiveChapter(activeChapter) {
		_activeChapter = activeChapter;
		entityCollection.updateChapterEntities(_activeChapter);
		shotCollection.updateChapterShots(_activeChapter);
		subtitleCollection.updateChapterSubtitles(_activeChapter);
	}

	//TODO waarom wordt deze zo vaak aangeroepen
	function getActiveChapter() {
		return _activeChapter;
	}

	function getAllEnrichmentsOfChapter(chapter) {
		if(!chapter) {
			chapter = _activeChapter;
		}
		var dimensions = chapter.dimensions;
		var all = [];
		_.each(dimensions, function(d) {
			all.push.apply(all, d.annotations);
		});
		return all;
	};

	function getSavedEnrichmentsOfDimension(dimension, chapter) {
		if(!chapter) {
			chapter = _activeChapter;
		}
		var enrichments = chapter.dimensions[dimension.id] ? chapter.dimensions[dimension.id].annotations : null;
		return enrichments ? enrichments.slice(0) : [];
	}

	function removeChapter(chapter) {
		_.each(_chapters, function(c, index){
			if(c.guid == chapter.guid) {
				_chapters.splice(index, 1);
			}
		});
		if(conf.programmeConfig.synchronization &&
			conf.programmeConfig.synchronization.syncOnSave &&
			chapter.solrId) {
			console.debug('Disconnecting chapter from external platform');
			synchronizationService.disconnectChapter(chapter);
		}
		saveOnServer();
		notifyObservers();
	}

	function saveChapter(chapter, entityExpand) {
		//first fetch the expanded entities (very slow)
		if(conf.programmeConfig.entityExpansion && entityExpand){
			entityExpansionService.fetch(_srtUrl, chapter.start, chapter.end, chapter.guid, onEntityExpand);
		} else {
			console.debug('No entity expansion for this provider');
		}

		var exists = false;
		chapter.type = TYPE_CURATED;
		chapter.start = parseInt(chapter.start);
		chapter.end = parseInt(chapter.end);
		for(c in _chapters) {
			if(_chapters[c].guid == chapter.guid) {
				setBasicProperties(chapter, false);
				_chapters[c] = chapter;
				exists = true;
				break;
			}
		}
		if(!exists) { //if it's a new chapter add it
			setBasicProperties(chapter, true);
			_chapters.push(chapter);
		}
		//sort the chapters again
		_chapters.sort(function(a, b) {
			return a.start - b.start;
		});
		//update the entire resource on the server
		saveOnServer(chapter);
		//notify observers
		notifyObservers();
	}

	function onEntityExpand(chapterId, data) {
		//set the data to the correct chapter in the list of chapters
		for(c in _chapters) {
			if(_chapters[c].guid == chapterId) {
				_chapters[c].expandedEntities = data;
				break;
			}
		}
		//also set the data to the active chapter
		if(_activeChapter.guid = chapterId) {
			_activeChapter.expandedEntities = data;
		}
		saveOnServer();
	}

	//TODO fix this! THis is a deadly bit of code, because it can be overseen easily! (so when you update the config.js
	// you also need to update this (when you want to add a property to a dimension)!!! (below also)
	function saveEnrichments(dimension, savedEnrichments, freshlySavedEnrichments, allEnrichments, queries) {
		//if user logging is enabled, save which enrichments were chosen by the user for which query
		if(conf.programmeConfig.logUserActions) {
			loggingService.logUserAction(allEnrichments, freshlySavedEnrichments, queries, _activeChapter.label);
		}
		//update the active chapter and save it
		_activeChapter.dimensions[dimension.id].annotations = savedEnrichments;
		saveChapter(_activeChapter);
	}

	//works for both information cards and enrichments (UGLY=check based on URI or URL :s :s)
	function saveEnrichment(dimension, enrichment, isInformationCard) {
		var dimensionAnnotations = _activeChapter.dimensions[dimension.id].annotations;
		if(enrichment.remove) {
			for(var i=0;i<dimensionAnnotations.length;i++) {
				if((!isInformationCard && dimensionAnnotations[i].url == enrichment.url) ||
					(isInformationCard && dimensionAnnotations[i].uri == enrichment.uri)) {
					dimensionAnnotations.splice(i, 1);
					break;
				}
			}
		} else if(dimensionAnnotations) {
			var exists = false;
			for(var i=0;i<dimensionAnnotations.length;i++){
				if((!isInformationCard && dimensionAnnotations[i].url == enrichment.url) ||
					(isInformationCard && dimensionAnnotations[i].uri == enrichment.uri)) {
					dimensionAnnotations[i] = enrichment;
					exists = true;
					break;
				}
			}
			if (!exists) {
				dimensionAnnotations.push(enrichment);
			}
		} else {
			//add a new dimension (add the config properties + a list to hold the annotations)
			//dimensionAnnotations = [enrichment];
			_activeChapter.dimensions[dimension.id].annotations = [enrichment];
		}
		saveChapter(_activeChapter);
	}

	//passing the chapter is optional (in all cases all data will be saved again)
	function saveOnServer(chapter) {
		//if configured, the changed chapter will be synchronized with an external platform prior to saving (see config.js)
		if(conf.programmeConfig.synchronization && conf.programmeConfig.synchronization.syncOnSave && chapter) {
			console.debug('Synchronizing chapter with external platform');
			synchronizationService.synchronizeChapter(chapter, onChapterSynched)
		} else {
			console.debug('Just saving all data on the server');
			dataService.saveResource(getCuratedChapters());
		}
	}

	function onChapterSynched(data) {
		if(data) {
			//make sure the solrId is added to the right chapter
			for(c in _chapters) {
				if(_chapters[c].guid == data.guid) {
					_chapters[c].solrId = data.solrId;
					break;
				}
			}

			//also update the active chapter (if applicable)
			if(_activeChapter && _activeChapter.guid == data.guid) {
				_activeChapter.solrId = data.solrId;
			}

			//now save this on the server
			dataService.saveResource(getCuratedChapters());
		}
	}

	return {
		initCollectionData : initCollectionData,
		getCuratedChapters : getCuratedChapters,
		getChapters : getChapters,
		setChapters : setChapters,
		saveOnServer : saveOnServer,
		setActiveChapter : setActiveChapter,
		getActiveChapter : getActiveChapter,
		getAllEnrichmentsOfChapter : getAllEnrichmentsOfChapter,
		getSavedEnrichmentsOfDimension : getSavedEnrichmentsOfDimension,
		removeChapter : removeChapter,
		saveChapter : saveChapter,
		saveEnrichment : saveEnrichment,
		saveEnrichments : saveEnrichments,
		addObserver : addObserver,
		removeObserver : removeObserver
	}

}]);